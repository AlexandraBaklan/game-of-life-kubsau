/**
 * Created with JetBrains WebStorm.
 * User: garffan
 * Date: 9/23/13
 * Time: 12:56 PM
 * To change this template use File | Settings | File Templates.
 */

/*
    Хранилище всех клеток, представляет собой двуммерный массив(матрица)
    Количество строк равно знчению переменной rowsCount
    Количество столбцов равно значению переменной columnsCount
 */
var cells = [];

// Собственно количество строк и количество столбцов
var rowsCount = 32,
    columnsCount = 32;

// Ширина и высота клетки при отображении на экране
var cellWidth = 30, cellHeight = 30;


// Функция которая вызывается при клике по клетке отображенной на экране
function onClickHandler(cell) {
    // Для поддержки ie6 - ie8, это нужно так как на компе в 403 ie8
    cell = cell || window.event;
    // Определяем номер строки и номер столбца, где находится наша клетка
    var rowId = cell.target.rowId, colId = cell.target.colId;
    // Если наша клетка жива в момент щелчка
    if (cells[rowId][colId].alive) {
        // Убиваем её и устанавливаем соответствующий цвет
        cells[rowId][colId].alive = false;
        cells[rowId][colId].rect.style.backgroundColor = 'white';
    } else {
        // Иначе мы её ожевляем и устанавливаем соответствующий цвет
        cells[rowId][colId].alive = true;
        cells[rowId][colId].rect.style.backgroundColor = 'black';
    }
    // Сбрасываем остальные параметры для клетки
    cells[rowId][colId].mustDie = false;
    cells[rowId][colId].mustBorn = false;
}

// Функция которая инициализирует игровое поле, а также создает все необходимые переменные
function init(_rowsCount, _columnsCount) {
    // Создаём массив клеток
    cells = [];

    // Если пользователь вызвал функцию с параметрами (т.е хочет установить кол-во строк и колонок вручную)
    if (_rowsCount && _columnsCount) {
        // То тогда мы присваеваем переданные пользователем значения, нашим переменным
        rowsCount = _rowsCount;
        columnsCount = _columnsCount;
    }

    // Очищаем игровое поле от всех ранее созданных клеток
    while (document.body.hasChildNodes()) {
        document.body.removeChild(document.body.firstChild);
    }

    /*
        Стартовая позиция, откуда будет рисоваться поле. Мы будем рисовать поле слева направо, сверху вниз.
     */
    var x = 150, y = 50;
    for (var i = 0; i < rowsCount; ++i) {
        // Добавляем новую строку в матрицу
        cells.push([]);
        // И смещаем позицию выводимого элемента на крайнюю левую позицию (мы же рисуем слева направо)
        x = 150;
        for (var j = 0; j < columnsCount; ++j) {
            // Создаем нашу клетку на экране
            var cellRect = document.createElement('div');
            // Указываем, что позиция клетки будет устанавливаться в пикселях
            cellRect.style.position = 'absolute';
            // Устанавливаем позицю элемента по оси X и оси Y
            cellRect.style.left = x + 'px';
            cellRect.style.top = y + 'px';
            // Устанавливаем размер(ширину и высоту) клетки
            cellRect.style.width = cellWidth + 'px';
            cellRect.style.height = cellHeight + 'px';
            // Устанавливаем границу для клетки, она будет иметь ширину в 1px, сплошная черта и цвет rgba(0,0,0,0.35)
            cellRect.style.border = '1px solid rgba(0,0,0,0.35)';
            // Устанавливаем параметры rowId и colId, по которым мы сможем узнать где в массиве находится наш элемент
            cellRect.rowId = i;
            cellRect.colId = j;
            // Устанавливаем обработчик щелчка мышки
            cellRect.onclick = onClickHandler;
            // Добавляем клетку на поле
            document.body.appendChild(cellRect);
            /*
                 Добавляем нашу клетку в массив клеток, добавив некоторые параметры :
                   - alive - Парметр отображает текущее состояние клетки (жива или мертва (true или false соответственно)
                   - mustDie - Параметр хранит информацию, должны ли мы убить клетку, или оставить в живых.
                   - mustBorn - Параметр хранит информацию, должны ли мы "создать" клетку, или ничего не делать
                   - rect - это наша клетка на экране
             */
            cells[i].push({
                alive : false,
                mustDie : false,
                mustBorn : false,
                rect : cellRect
            });

            // После создания клетки, мы должны указатель на текущюю позицию по оси X сместить на ширину клетки
            x += cellWidth;
        }
        /*
            После создания одной строки, для продолжения мы должны перейти к созданию следующей строки.
            Для этого мы должгы указатель на текущюю позицию по оси Y сместить на высоту клетки
         */
        y += cellHeight;
    }
}

// Функция расчитывает состояние всех клеток на поле
function updateGameData() {
    // Проходим по массиву клеток
    for (var i = 0; i < rowsCount; ++i) {
        for (var j = 0; j < rowsCount; ++j) {
            /*
                Согласно алгоритму Game Of Life, нам нужно узнать кол-во живых соседей
                Для клетки, которая находится на строке i, в колонке j соседями являются :
                    [i - 1][j - 1] [i - 1][j] [i - 1][j + 1]

                    [i][j - 1]       [i][j]       [i][j + 1]

                    [i + 1][j - 1] [i + 1][j] [i + 1][j + 1]
                Все клетки вокруг неё кроме самой клетки [i][j]
                Но существуют некоторые граничные случаи, когда некоторые соседи отсутсвуют,
                например если i = 0 и j = 0, т.е она находится в левом верхнем углу, у неё отсутсвуют следующие соседи:
                 [i - 1][j - 1], [i - 1][j], [i - 1][j + 1], [i][j - 1], [i + 1][j - 1]
                Перед тем как мы будем проходить по соседям и подсчитывать живых, мы определим
                каких соседей мы, будем подсчитывать, кто их нех есть рядом с проверяймой клеткой
             */

            var leftEdge = -1,  // Левая граница наших соседей
                rightEdge = 1,  // Правая граница наших соседей
                topEdge = -1,   // Верхняя граница наших соседей
                bottomEdge = 1; // Нижняя граница наших соседей

            // Итак, если мы сейчас находимся на самой первой строке
            if ( i == 0 ) {
                // То сразу можно сказать, что выше нас нет никого
                topEdge = 0;
            } else {
                // Если мы попали сюда, значит мы точно не на первой строке, но тогда на какой мы строке
                // Может мы на последней строке
                if (i == rowsCount - 1) {
                    // То ниже нас никого нет
                    bottomEdge = 0;
                }
            }
            // Теперь проверм в какой колонке мы находимся
            if (j == 0) {
                // Если это самая левая граница (первый столбец), то левее нас никого нет
                leftEdge = 0;
            }
            // Если это самая правая (последний столбец)
            if (j == columnsCount - 1) {
                // То правее нас никого нет
                rightEdge = 0;
            }

            // В этой переменной мы будем хранить число живых соседей
            var aliveCount = 0;
            /*
                Проходим всех наших соседей, но надо учесть, что наша клетка также входит в отрезок :
                [i - 1][j - 1] ... [i][j] ... [i + 1][j + 1]
             */
            for (var k = i + topEdge; k <= i + bottomEdge; ++k) {
                for (var l = j + leftEdge; l <= j + rightEdge; ++l) {
                    /*
                        Поэтому, если в процессе прохода по соседям мы наткнулись на себя,
                        то мы должны пропустить текущюю иттерацию
                     */
                    if (k == i && l == j) continue;
                    // Ну, а если это наш сосед и он живой, то увеличиваем наш счётчик
                    if (cells[k][l].alive) aliveCount++;
                }
            }

            /*
                Теперь когда мы посчитали кол-во живых соседей, обратимся к алгоритму, там написано :
                    - Если улетка жива, и возле неё либо меньше 2-х, либо больше 3-х живых соседей, то он умирает
                    - Если клетка жива и возле неё 2 - 3 живых соседа, то она живёт дальше
                    - Если клетка мертва и возле ней 3 живых соседа, то рождается новая клетка

                В процессе, мы будем помечать некоторые клетки как клетки которые должны родиться, и как те которые
                должны умереть. Замечу, что здесь мы их только помечаем, убивать или создавать новые клетки мы будем
                в функции drawGameData. Это нужно, т.к если мы будем здесь убивать или создавать новые клетки, то
                у нас не будет корректной картины мира. Например если вначале у живой клетки [i][j] был 1 сосед [i][j + 1]
                т.е по алгоритму она должна умереть от одиночества. Но в процессе работы программы мы оживили клетку
                [i][j - 1], то теперь при проверки клетки [i][j] мы получим, что у неё уже 2 соседа, и нам уже не надо
                убивать нашу клетку. И вообще при таком методе работе получается, что если клетка [i][j] и клетка [i][j + 1]
                должны умереть, то сначала умрёт клетка [i][j], а потом (и то не факт) умрёт [i][j + 1].
                В реальном мире так не происходит, в реальном мире если две клетки должны умереть, то одна не ждёт другую.
                Поэтому сначала мы пометим тех кто должен родиться, и тех кто должен умереть, а затем оживим или убьём.
             */

            // Так вот, если клетка жива
            if (cells[i][j].alive) {
                // Смотрим количество живых соседей ...
                if (aliveCount < 2 || aliveCount > 3) {
                    // Ага у нас тут либо меньше 2 - х, либо больше 3 - х
                    // Значит помечаем её как клетку, которая должна умереть
                    cells[i][j].mustDie = true;
                    cells[i][j].mustBorn = false;
                }
            } else {
                // Так наша клетка мертва, и оживить мы её можем только если рядом 3 соседа, проверим это
                if (aliveCount == 3) {
                    // Ага у нас 3 соседа, помечаем её как клетку которая должна родиться
                    cells[i][j].mustDie = false;
                    cells[i][j].mustBorn = true;
                }
            }
        }
    }
}

// Функция отрисовки поля
function drawGameData() {
    // Проходим по всему массиву клеток
    for (var i = 0; i < rowsCount; ++i) {
        for (var j = 0; j < columnsCount; ++j) {
            // Если клетка жива
            if (cells[i][j].alive) {
                // То надо проверить должны ли мы убить эту клетку
                if (cells[i][j].mustDie) {
                    // Если так, то мы убиваем клетку и окрашиваем поле в соответствующий цвет
                    cells[i][j].alive = false;
                    cells[i][j].rect.style.backgroundColor = 'white';
                } else {
                    // Иначе просто окрашиваем поле в чёрный
                    cells[i][j].rect.style.backgroundColor = 'black';
                }
            } else {
                // Иначе, если клетка мертва, мы должны проверить, оживить ли её
                if (cells[i][j].mustBorn) {
                    // Если мы должны, то оживляем её и окрашиваем поле в соответствующий цвет
                    cells[i][j].alive = true;
                    cells[i][j].rect.style.backgroundColor = 'black';
                } else {
                    // Иначе просто окрашиваем пол в белый
                    cells[i][j].rect.style.backgroundColor = 'white';
                }
            }
            // В любом случае сбрасываем данные поля для клетки
            cells[i][j].mustDie = false;
            cells[i][j].mustBorn = false;
        }
    }
}

// Тут будет храниться идентификатор таймера, который запускает нашу код
var gameInterval = 0;

// Функция запуска игры, она 10 раз в секунду обрабатывает расчитывает состояние поля и клеток, и отрисовывает клетки
function startGame() {
    gameInterval = setInterval(function() {
        updateGameData();
        drawGameData();
    }, 1000 / 10);
}

// Сброс состояния игры
function resetGame() {
    // Останавливаем игру
    clearInterval(gameInterval);
    // Проходим по массиву клеток и сбрасываем их состояние, до состояния по-умолчанию
    for (var i = 0; i < rowsCount; ++i) {
        for (var j = 0; j < columnsCount; ++j) {
            cells[i][j].alive = false;
            cells[i][j].mustDie = false;
            cells[i][j].mustBorn = false;
        }
    }
    // Отрисовыаем анше поле до состояния по-умолчанию
    drawGameData();
}
